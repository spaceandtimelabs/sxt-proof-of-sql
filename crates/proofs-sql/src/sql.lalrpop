use crate::intermediate_ast;
use crate::symbols;
use lalrpop_util::ParseError::User;

grammar;

////////////////////////////////////////////////////////////////////////////////////////////////
// Everything we allow in the PoSQL engine have to be SELECT
////////////////////////////////////////////////////////////////////////////////////////////////

pub SelectStatement: intermediate_ast::SelectStatement = {
    <expr: SelectCoreList> => 
        intermediate_ast::SelectStatement {
            expr,
        },
};

SelectCoreList: Box<intermediate_ast::SetExpression> = {
    SelectCore,
};

SelectCore: Box<intermediate_ast::SetExpression> = {
    "SELECT" <columns:ResultColumnList> <from:FromClause> <where_expr:WhereClause> =>
        Box::new(intermediate_ast::SetExpression::Query{ columns, from, where_expr }),
};

////////////////////////////////////////////////////////////////////////////////////////////////
// Result Columns
////////////////////////////////////////////////////////////////////////////////////////////////

ResultColumnList: Vec<Box<intermediate_ast::ResultColumn>> = {
    ResultColumn => vec![<>],

    <columns:ResultColumnList> "," <column:ResultColumn> => intermediate_ast::append(columns, column),
};

ResultColumn: Box<intermediate_ast::ResultColumn> = {
    <expr: QualifiedColumnIdentifier> => Box::new(intermediate_ast::ResultColumn::Expr { expr }),
};

QualifiedColumnIdentifier: symbols::Name = {
    Identifier,
};

////////////////////////////////////////////////////////////////////////////////////////////////
// FromClause
////////////////////////////////////////////////////////////////////////////////////////////////

FromClause: Vec<Box<intermediate_ast::TableExpression>> = {
    "FROM" <table_ref: TableExpressionList> => table_ref,
};

TableExpressionList: Vec<Box<intermediate_ast::TableExpression>> = {
    TableExpression => vec![<>],
};

TableExpression: Box<intermediate_ast::TableExpression> = {
    <table: QualifiedTableIdentifier> => table,

    "(" <table_ref: TableExpression> ")" => table_ref,
};

QualifiedTableIdentifier: Box<intermediate_ast::TableExpression> = {
    <table: Identifier> =>
        Box::new(intermediate_ast::TableExpression::Named { table, namespace: None }),

    <namespace: Identifier> "." <table: Identifier> =>
        Box::new(intermediate_ast::TableExpression::Named { table, namespace: Some(namespace) }),
};

////////////////////////////////////////////////////////////////////////////////////////////////
// WhereClause
////////////////////////////////////////////////////////////////////////////////////////////////

WhereClause: Box<intermediate_ast::Expression> = {
    "WHERE" <expr:Expression> => expr,
};

////////////////////////////////////////////////////////////////////////////////////////////////
// Expressions
////////////////////////////////////////////////////////////////////////////////////////////////

Expression: Box<intermediate_ast::Expression> = {
    NotExpression,
    OrExpression,
    AndExpression,
    EqualityExpression,
};

AndExpression: Box<intermediate_ast::Expression> = {
    "(" <left:Expression> ")" "AND" "(" <right:Expression> ")" =>
        Box::new(intermediate_ast::Expression::And { left, right }),
};

OrExpression: Box<intermediate_ast::Expression> = {
    "(" <left:Expression> ")" "OR" "(" <right:Expression> ")" =>
        Box::new(intermediate_ast::Expression::Or { left, right }),
};

NotExpression: Box<intermediate_ast::Expression> = {
    "NOT" "(" <expr:Expression> ")" => Box::new(intermediate_ast::Expression::Not { expr }),
};

EqualityExpression: Box<intermediate_ast::Expression> = {
    <left:QualifiedColumnIdentifier> "=" <right: UnaryExpression> =>
        Box::new(intermediate_ast::Expression::Equal { left, right }),
};

UnaryExpression: i64 = {
    NumericLiteral,

    "+" <expr: UnaryExpression> => expr,

    "-" <expr: UnaryExpression> => -1 * expr,
};

////////////////////////////////////////////////////////////////////////////////////////////////
// Tokens
////////////////////////////////////////////////////////////////////////////////////////////////

Identifier: symbols::Name = ID => symbols::Name::from(<>);

NumericLiteral: i64 = {
    NUMERIC_LIT =>? <>.parse::<i64>().map_err(|_| User {error: "Integer out of range"}),
};

////////////////////////////////////////////////////////////////////////////////////////////////
// Lexer specification, with the primary purpose of making language keywords case insensitive //
////////////////////////////////////////////////////////////////////////////////////////////////

match {
    r"(?i)and" => "AND",
    
    r"(?i)from" => "FROM",

    r"(?i)not" => "NOT",

    r"(?i)or" => "OR",

    r"(?i)select" => "SELECT",

    r"(?i)where" => "WHERE",

    "," => ",",
    "." => ".",
    "(" => "(",
    ")" => ")",
    "+" => "+",
    "-" => "-",
    "*" => "*",
    "/" => "/",
    "=" => "=",
    "==" => "==",
    "!=" => "!=",
    "<>" => "<>",
} else {
    r"[A-Za-z_][A-Za-z0-9_]*" => ID,
    r"[+-]?[0-9]+([0-9]*)" => NUMERIC_LIT,
}
